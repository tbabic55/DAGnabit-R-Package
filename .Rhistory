getwd()
devtools::document()
rm(list = c("DAGnabitWidget", "DAGnabitWidgetOutput", "renderDAGnabitWidget"))
devtools::document()
rm(list = c("hello", "parse_graph", "plot_dag"))
devtools::document()
devtools::load_all()
DAGnabit::hello("Tamara")
nodes <- data.frame(label = c("A", "B", "C"))
edges <- data.frame(from = c("A", "B"), to = c("B", "C"))
DAGnabit::plot_dag(nodes, edges)
search()
devtools::document()
devtools::build()
devtools::install()
library(DAGnabit)
nodes <- data.frame(id = 1:3, label = c("A","B","C"))
edges <- data.frame(from = c(1,2), to = c(2,3))
DAGnabitWidget(nodes, edges)
library(DAGnabit)
nodes <- data.frame(id = 1:3, label = c("A","B","C"))
edges <- data.frame(from = c(1,2), to = c(2,3))
w <- DAGnabitWidget(nodes, edges)
w
class(w)
htmlwidgets::getDependency("DAGnabitWidget")
htmlwidgets::saveWidget(w, "test.html", selfcontained = TRUE)
browseURL("test.html")
devtools::document()
devtools::load_all()
htmlwidgets::getDependency("DAGnabitWidget")
devtools::document()
devtools::load_all()
htmlwidgets::getDependency("DAGnabitWidget")
# R/hello.R
hello_code <- '
#\' Say hello
#\' @param name Your name
#\' @export
hello <- function(name = "world") {
message(paste("DAGnabit,", name, "!"))
}
'
writeLines(hello_code, file.path(pkg, "R/hello.R"))
devtools::document()
devtools::load_all()
nodes <- data.frame(id = 1:3, label = c("A","B","C"))
edges <- data.frame(from = c(1,2), to = c(2,3))
DAGnabitWidget(nodes, edges)
devtools::document()
devtools::install()
devtools::document()
devtools::document()
devtools::load_all()
devtools::install()
library(DAGnabit)
devtools::load_all()
library(DAGnabit)
devtools::load_all()
rmarkdown::render("DAGnabit_demo.Rmd")
# ---- 0. Config: set your project root (folder with DESCRIPTION) ----
# If you're already in the project, you can keep getwd().
proj <- getwd()
# ---- 0. Config: set your project root (folder with DESCRIPTION) ----
# If you're already in the project, you can keep getwd().
proj <- getwd()
message("Project root: ", proj)
# ---- 1. Ensure packages ----
need <- c("DAGnabit", "devtools", "rmarkdown", "htmlwidgets")
for (p in need) {
if (!requireNamespace(p, quietly = TRUE)) {
install.packages(p)
}
}
# Load DAGnabit after install
suppressPackageStartupMessages(library(DAGnabit))
# ---- 2. Quick widget dependency check ----
# Should list htmlwidgets AND d3 (from YAML) if YAML is wired correctly
wd_deps <- try(htmlwidgets::getDependency("DAGnabitWidget"), silent = TRUE)
# Format a simple summary line for deps
fmt_dep <- function(d) {
if (is.null(d)) return("<none>")
paste0("[", paste0(vapply(d, function(x) paste0(x$name, "@", x$version), ""), collapse = ", "), "]")
}
# ---- 3. Write the Rmd ----
rmd_path <- file.path(proj, "DAGnabit_demo.Rmd")
rmd_lines <- c(
"---",
"title: 'DAGnabit Demo'",
paste0("author: '", Sys.info()["user"], "'"),
paste0("date: '", as.character(Sys.Date()), "'"),
"output:",
"  html_document:",
"    toc: true",
"    toc_float: true",
"---\n",
"```{r setup, include=FALSE}",
"library(DAGnabit)",
"```\n",
"# 1) Hello test",
"Simple sanity check that package loads and hello() works.",
"\n```{r}",
"hello('Tamara')",
"```\n",
"# 2) Simple igraph DAG test",
"Static plot via plot_dag().",
"\n```{r fig.width=6, fig.height=4}",
"nodes <- data.frame(label = c('A','B','C'))",
"edges <- data.frame(from = c('A','B'), to = c('B','C'))",
"plot_dag(nodes, edges)",
"```\n",
"# 3) Parse graph test",
"parse_graph() returns nodes/edges; nodes must have a 'label' column.",
"\n```{r}",
"nodes_txt <- 'label|plates\\nA|none\\nB|none\\nC|none'",
"edges_txt <- 'from,to\\nA,B\\nB,C'",
"parsed <- parse_graph(nodes_txt, edges_txt)",
"str(parsed)",
"plot_dag(parsed$nodes, parsed$edges)",
"```\n",
"# 4) HTML widget test (D3)",
"Interactive widget should render below.",
"\n```{r}",
"DAGnabitWidget(parsed$nodes, parsed$edges, width = 600, height = 400)",
"```\n"
)
writeLines(rmd_lines, rmd_path)
message("Wrote Rmd to: ", rmd_path)
# ---- 4. Knit the Rmd to HTML ----
out_html <- file.path(proj, "DAGnabit_demo.html")
tryCatch({
rmarkdown::render(rmd_path, output_file = out_html, quiet = FALSE)
message("Knit OK: ", out_html)
}, error = function(e) {
message("Knit FAILED: ", conditionMessage(e))
})
# ---- 5. Write diagnostics ----
diag_path <- file.path(proj, "_diagnostics.txt")
con <- file(diag_path, open = "wt", encoding = "UTF-8")
writeLines(c(
paste0("Project: ", proj),
paste0("Rendered: ", file.exists(out_html), " -> ", out_html),
paste0("Widget deps: ", fmt_dep(if (inherits(wd_deps, 'try-error')) NULL else wd_deps)),
"",
"Session info:",
capture.output(utils::sessionInfo())
), con)
close(con)
message("Wrote diagnostics to: ", diag_path)
# Tip: Open the HTML in your browser using explorer()
# Tip: Open the HTML in your browser using explorer()
# utils::browseURL(out_html)
# Tip: Open the HTML in your browser using explorer()
devtools::document()
devtools::load_all()
htmlwidgets::getDependency("DAGnabitWidget")
devtools::document()
devtools::load_all()
htmlwidgets::getDependency("DAGnabitWidget")
install.packages(c("usethis", "devtools", "roxygen2", "igraph", "htmlwidgets", "testthat"))
library(devtools)
library(roxygen2)
setwd("C:/Users/tbabic/Documents/DAGnabit")
load_all(".")
nodes <- data.frame(label = c("A", "B", "C"))
edges <- data.frame(from = c("A","B"), to = c("B","C"))
DAGnabit::plot_dag(nodes, edges)
#' Say hello
#'
#' A simple test function for the DAGnabit package.
#' @param name A character string containing your name.
#' @return Prints a friendly message.
#' @export
hello <- function(name = "world") {
message(paste("DAGnabit,", name, "!"))
}
hello("Tamara")  # simple test
#' Build and plot a DAG
#'
#' Takes a list of nodes and edges, builds a DAG using igraph, and plots it.
#'
#' @param nodes A data.frame with column `label` for node names.
#' @param edges A data.frame with columns `from` and `to`.
#' @param layout_func An igraph layout function (default: layout_with_kk)
#' @return The igraph graph object (invisibly)
#' @import igraph
#' @export
plot_dag <- function(nodes, edges, layout_func = igraph::layout_with_kk) {
stopifnot("label" %in% names(nodes))
stopifnot(all(c("from", "to") %in% names(edges)))
# Build igraph object
g <- igraph::graph_from_data_frame(d = edges, vertices = nodes, directed = TRUE)
# Compute layout
layout_mat <- layout_func(g)
# Plot DAG
igraph::plot.igraph(
g,
layout = layout_mat,
vertex.label.color = "black",
vertex.color = "lightblue",
vertex.size = 30,
edge.arrow.size = 0.3,
vertex.label.cex = 0.8
)
invisible(g)
}
plot_dag(nodes, edges)  # should plot DAG
#' Parse nodes and edges from text input
#'
#' Converts node and edge descriptions into data frames for plotting DAGs.
#'
#' @param nodes_txt Character string describing nodes, e.g. "A|none\nB|none"
#' @param edges_txt Character string describing edges, e.g. "from,to\nA,B\nB,C"
#' @return A list with elements `nodes` and `edges` as data frames
#' @export
parse_graph <- function(nodes_txt, edges_txt) {
nodes <- read.delim(text = nodes_txt, sep = "|", stringsAsFactors = FALSE)
edges <- read.csv(text = edges_txt, stringsAsFactors = FALSE)
list(nodes = nodes, edges = edges)
}
library(magrittr)
nodes_txt <- "label|plates
A|none
B|none
C|none
D|none"
edges_txt <- "from,to
A,B
A,C
B,D
C,D"
graph_data <- parse_graph(nodes_txt, edges_txt)
plot_dag(graph_data$nodes, graph_data$edges)
library(shiny)
# Avoid the validate masking warning
jsonlite::validate
library(ggplot2)
ui <- fluidPage(
sliderInput("n", "Number of points:", min = 10, max = 100, value = 50),
plotOutput("plot")
)
server <- function(input, output, session) {
output$plot <- renderPlot({
df <- data.frame(x = rnorm(input$n), y = rnorm(input$n))
ggplot(df, aes(x, y)) + geom_point()
})
}
shinyApp(ui, server)
library(plotly)
library(ggplot2)
df <- data.frame(x = rnorm(50), y = rnorm(50))
p <- ggplot(df, aes(x, y)) + geom_point()
ggplotly(p)  # Converts ggplot to interactive plot
library(igraph)
library(visNetwork)
g <- make_ring(10)
nodes <- data.frame(id = 1:10)
edges <- as_data_frame(g, what = "edges")
visNetwork(nodes, edges) %>% visEdges(arrows = "to")
#' DAGnabit HTML Widget
#'
#' @param nodes Data frame of nodes
#' @param edges Data frame of edges
#' @param width Widget width
#' @param height Widget height
#' @param ... Additional options passed to JS
#' @export
DAGnabitWidget <- function(nodes, edges, width = NULL, height = NULL, ...) {
data <- list(
nodes = nodes,
edges = edges,
options = list(...)
)
htmlwidgets::createWidget(
name = "DAGnabitWidget",
x = data,
width = width,
height = height,
package = "DAGnabit"
)
}
#' Shiny output binding
#' @export
DAGnabitWidgetOutput <- function(outputId, width = "100%", height = "400px") {
htmlwidgets::shinyWidgetOutput(outputId, "DAGnabitWidget", width, height, package = "DAGnabit")
}
#' Shiny render function
#' @export
renderDAGnabitWidget <- function(expr, env = parent.frame(), quoted = FALSE) {
if (!quoted) expr <- substitute(expr)
htmlwidgets::shinyRenderWidget(expr, DAGnabitWidgetOutput, env, quoted = TRUE)
}
#' helloWidget: Simple HTML Widget
#'
#' Provides an interactive HTML widget for visualizing DAGs.
"_PACKAGE"
inst/htmlwidgets/lib/vis/vis-network.min.js
inst/htmlwidgets/lib/vis/vis-network.min.css
list.files("inst/htmlwidgets/lib/vis", full.names = TRUE)
usethis::use_vignette("introduction")
library(DAGnabit)
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
str(parsed$nodes)
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
str(parsed$nodes)
rm(parse_graph)
devtools::load_all()
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
str(parsed$nodes)
library(DAGnabit)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(DAGnabit)
hello("Tamara")
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
plot_dag(parsed$nodes, parsed$edges)
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
plot_dag(parsed$nodes, parsed$edges)
DAGnabitWidget(parsed$nodes, parsed$edges, width = 600, height = 400)
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
str(parsed$nodes)
str(parsed$edges)
plot_dag(parsed$nodes, parsed$edges)
parsed <- parse_graph(nodes_txt, edges_txt)
# test input strings
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
# run your parse function
parsed <- parse_graph(nodes_txt, edges_txt)
# check the structure of outputs
str(parsed$nodes)
str(parsed$edges)
# try plotting
plot_dag(parsed$nodes, parsed$edges)
# test input strings
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
# run your parse function
parsed <- parse_graph(nodes_txt, edges_txt)
# check the structure of outputs
str(parsed$nodes)
str(parsed$edges)
# try plotting
plot_dag(parsed$nodes, parsed$edges)
# test input strings
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
# run your parse function
parsed <- parse_graph(nodes_txt, edges_txt)
# check the structure of outputs
str(parsed$nodes)
str(parsed$edges)
# try plotting
plot_dag(parsed$nodes, parsed$edges)
parsed <- parse_graph("A|none\nB|none\nC|none",
"from,to\nA,B\nB,C")
str(parsed$nodes)
str(parsed$edges)
plot_dag(parsed$nodes, parsed$edges)
# try plotting
plot_dag(parsed$nodes, parsed$edges)
parsed <- parse_graph("A|none\nB|none\nC|none",
"from,to\nA,B\nB,C")
str(parsed$nodes)
str(parsed$edges)
plot_dag(parsed$nodes, parsed$edges)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(DAGnabit)
hello("Tamara")
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
plot_dag(parsed$nodes, parsed$edges)
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
plot_dag(parsed$nodes, parsed$edges)
setwd("C:/Users/tbabic/Documents/DAGnabit")
devtools::document()
devtools::load_all()
rm(list = c("parse_graph", "plot_dag", "hello"), inherits = TRUE)
devtools::load_all()
search()                # should include "package:DAGnabit"
getAnywhere(parse_graph) # should show from namespace:DAGnabit
getAnywhere(plot_dag)    # should show from namespace:DAGnabit
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
str(parsed$nodes)  # expect ONLY column "label"
str(parsed$edges)  # expect columns "from","to"
plot_dag(parsed$nodes, parsed$edges)  # should draw A->B->C
devtools::load_all()
devtools::build_vignettes()
browseVignettes("DAGnabit")
library(DAGnabit)
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
# Diagnostic prints
str(parsed$nodes)  # check column names
str(parsed$edges)
# Plot
plot_dag(parsed$nodes, parsed$edges)
unlink("DAGnabit/vignettes/introduction_cache", recursive = TRUE, force = TRUE)
unlink("DAGnabit/vignettes/introduction_files", recursive = TRUE, force = TRUE)
devtools::build_vignettes()
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
# ðŸ”§ Patch in case column name isn't "label"
if (!"label" %in% names(parsed$nodes)) {
colnames(parsed$nodes)[1] <- "label"
}
# Diagnostic prints
str(parsed$nodes)
str(parsed$edges)
# Plot
plot_dag(parsed$nodes, parsed$edges)
parsed$nodes
parsed$edges
parsed$edges$from <- trimws(as.character(parsed$edges$from))
parsed$edges$to   <- trimws(as.character(parsed$edges$to))
parsed$nodes$label <- trimws(as.character(parsed$nodes$label))
plot_dag(parsed$nodes, parsed$edges)
devtools::load_all()
devtools::build_vignettes()
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
# ðŸ”§ Patch in case column name isn't "label"
if (!"label" %in% names(parsed$nodes)) {
colnames(parsed$nodes)[1] <- "label"
}
# Diagnostic prints
str(parsed$nodes)
str(parsed$edges)
# Clean up columns
parsed$nodes$label <- trimws(as.character(parsed$nodes$label))
parsed$edges$from  <- trimws(as.character(parsed$edges$from))
parsed$edges$to    <- trimws(as.character(parsed$edges$to))
# Plot
plot_dag(parsed$nodes, parsed$edges)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(DAGnabit)
hello("Tamara")
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
# ðŸ”§ Patch in case column name isn't "label"
if (!"label" %in% names(parsed$nodes)) {
colnames(parsed$nodes)[1] <- "label"
}
# Diagnostic prints
str(parsed$nodes)
str(parsed$edges)
# Clean up columns
parsed$nodes$label <- trimws(as.character(parsed$nodes$label))
parsed$edges$from  <- trimws(as.character(parsed$edges$from))
parsed$edges$to    <- trimws(as.character(parsed$edges$to))
# Plot
plot_dag(parsed$nodes, parsed$edges)
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
plot_dag(parsed$nodes, parsed$edges)
devtools::load_all()
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
plot_dag(parsed$nodes, parsed$edges)
devtools::load_all()
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
plot_dag(parsed$nodes, parsed$edges)
devtools::load_all()
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
plot_dag(parsed$nodes, parsed$edges)
nodes_txt <- "A|none\nB|none\nC|none"
edges_txt <- "from,to\nA,B\nB,C"
parsed <- parse_graph(nodes_txt, edges_txt)
str(parsed$nodes)
str(parsed$edges)
devtools::load_all()
parsed <- parse_graph("A|none\nB|none\nC|none",
"from,to\nA,B\nB,C")
str(parsed$nodes)
str(parsed$edges)
plot_dag(parsed$nodes, parsed$edges)
devtools::load_all()
